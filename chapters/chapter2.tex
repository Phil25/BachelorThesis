\chapter{(TODO: name)}
\section{Source engine dedicated servers}

Valve's game engine, Source, is the engine behind many popular titles such as Half-Life 2, Counter-Strike: Global Offensive or Team Fortress 2 (TODO: refernce games).
It allows for running headless instances of any of its games, internally called \textit{mods}, through their Source Dedicated Server tool (srcds) on Linux, Windows and MacOS.
The term \textit{mods} comes from the fact that originally all games started as extensions of the base game -- Half-Life 2.

The directory structure is the most relevant aspect of the server and both convention and the engine enforce placement of files in specific directories.
In the root of the server the most important ones are:
\begin{itemize}
    \item \textbf{bin} -- TODO,
    \item \textbf{\textit{mod}} -- abbreviated name of the mod, stores game specific assets,
    \item \textbf{hl2} -- assets from the base game, Half-Life 2,
    \item \textbf{cfg} -- configuration presets for the game and server extensions.
\end{itemize}
Under \textbf{\textit{mod}}, there exists another structure, mostly to group different kinds of assets, like models, textures.
The noteworthy directory is \textbf{addons}.
In it, each folder corresponds to different extensions, C++ libraries that modify the behavior of the server \cite{server-plugins}.

Source engine exposes a set of interfaces they may interact with, for instance, capture an event of a player connecting.
Unfortunately, these interfaces are the only API an extension may safely use.
Interacting with server classes is possible, but not without risks.
Afterwards, the developer needs to build the extension along with the Source SDK.
Setting up the environment may be challenging as there are separate releases for each of the platforms.

The caveats of extension development are twofold:
\begin{enumerate}
\item
The API that the Source engine provides is very bare bones and lacking features often required in servers of any kind, such as external database querying.
This leaves the developer to implement their own solutions, which may unnecessarily vary from one extension to another.
\item
The fact that extensions are natively built C++ libraries forces the developer to write and provide support for platform-dependent code.
Using different SDK's across platforms adds great overhead to both development and deployment.
\end{enumerate}
SourceMod seeks to alleviate these problems by wrapping the underlying C++ API with its own, exposed in a simple scripting language called SourcePawn.
Developing a SourceMod plugin allows programmers to extend the functionality of game servers in OS-agnostic way.
On top of that, the new API provides them with more tools beyond than just altering server behavior.
Developers are granted features such as a MySQL database driver or a parser for Valve-specific configuration files right from the base API.

\section{SourceMod as platform for extensibility}

Installing SourceMod is as simple as extracting its archive into \textbf{mod/addons/}, after which \textbf{mod/addons/sourcemod/} will look as follows:
\begin{itemize}
    \item \textbf{bin} -- SourceMod specific binaries,
    \item \textbf{cfg} -- configuration files for plugins or extensions,
    \item \textbf{plugins} -- plugin binaries,
    \item \textbf{extensions} -- extension binaries,
    \item \textbf{gamedata} -- text files storing game's variable memory offsets and function signatures to be shared across plugins for more complex extensibility capabilities,
    \item \textbf{scripting} -- plugin sources and the SourcePawn compiler,
    \item \textbf{translations} -- text files storing phrases for localization.
\end{itemize}

A plugin is a binary compiled by the SourcePawn compiler, it is independent of the operating system and handled exclusively by SourceMod.
An extension is required for low-level control which goes beyond the scope of plugins, which in practise is very rare.
Both plugins and extensions are loaded by SourceMod, but the latter are C++ libraries and thus system-dependent.
To give an example, a plugin is a menu pop-up in the game, while an extension is a database driver.

In relation to the aforementioned directory structure and Source engine conventions, SourceMod expects a sort of order.
A plugin loads localization only from \textbf{translations}, or function signatures from \textbf{gamedata}.
Ultimately, it is up to the plugin what to do and where to load its files from.
For instance, if it comes bundled with assets, they usually are not placed in the SourceMod directory at all, but rather two directories up, alongside server files.

Considering a server is usually on a remote machine, it becomes cumbersome to download and install each file in its appropriate directory through CLI.
Operators understandably resolve to downloading the plugin to their computers, then using an FTP client to send the files over.
This process is not ideal and graphical approaches are not very flexible nor extensible.
Furthermore, it is problematic to automate, given there exists no standard on how to distribute plugins.

When a novice wishes to install a plugin, they must resolve to looking up instructions provided by the author.
These are usually found in a readme file that comes with it, or posted on a website where it was published.
The most common of such websites are the official forums -- AlliedModders \cite{alliedmodders-plugins}.
Developers write a post in an appropriate section with general information and installation instructions, and attach plugin files or a packaged archive.
By no means this is enforced.
The developer is free to omit any of these steps, even publish their work on other sites, like GitHub, if it suits them better.
Undoubtedly, this adds yet additional overhead from the server operator perspective.

\section{Package managers}

Package managers are administrative tools which automate installation of software packages.
Their goal is to download a set of files constituting a package, place them in correct directories and keep track of them.
Along with that automation come three perks, which are missing from the SourceMod community:
\begin{itemize}
    \item simplifying the installation process to a single command,
    \item automatically resolving potential dependencies on other packages,
    \item standardizing the process of distribution.
\end{itemize}

The latter is usually thanks to a database associated with the package manager (TODO: cite).
It provides the metadata on how to deal with a package, whether it would be its installation, removal, building from source or resolving dependencies.
This makes most package managers dependent on external sources of information, either official or third-party.
An important thing to note here is that a database is available right from the inception of the corresponding package manager.

Implementing exactly the same solution for SourceMod plugins would force all developers to update their mean of distribution, should they want to make use of it.
Considering the community is over ten years old, this severely undermines the usefulness of a dedicated package manager.
The developer must be in charge of the files, but not necessarily the metadata.
However, the database does not need to host the files.
