\chapter{Solution}

\section{Current publishing conventions}

Although there is no set standard on how to publish plugins, conventions have emerged over time.
Taking advantage of them is the first step towards standardizing distribution.

There are three websites where either the important ones or the majority of plugins are found:
\begin{itemize}
    \item \textbf{AlliedModders forums} -- official forums of SourceMod, usually there exists a corresponding thread, regardless where the files are hosted,
    \item \textbf{GitHub} -- preferred by some developers, either to upload binaries directly to repositories or have them posted in the \textit{Releases} section,
    \item \textbf{LimeTech} -- third-party website hosting high-traffic SourceMod extensions, owned by one of the major contributors.
\end{itemize}

\subsection{AlliedModders forums}

The official forums are the main source of advertising for developers, thus a sure way to find plugins.
A thread dedicated to a release of one, either hosts the files as its attachments or instructs readers where to download them from.
All addons posted on the forums must adhere to the SourceMod license, GNU General Public License, version 3.
This license applies to derivative works as well \cite{sourcemod-license}, which means that source must be provided along with distribution.

Because of this the forums have a unique feature available to developers when posting their work.
If a file is the source of a plugin (\textit{.sp} extension), it will automatically be compiled by the online compiler and displayed next to the source attachment.
While convenient, it is quite limited.
Should a plugin make use of libraries outside of the standard, the compilation will fail.
In such cases, the developer needs to compile the plugin themselves and upload it as a separate attachment.
Each are given and identified by a unique ID, which is utilized for downloading by being present in the URL.
Unfortunately, there is no API to parse them.

\subsection{GitHub}

GitHub is a preferable alternative to the forums as a file host by many developers.
For that, they mostly use the \textit{Releases} feature of the service but may store binary files along with everything else.
In case of the latter, there exists a URL which will always point to the latest version of any file in the repository.
A similar URL may exist pointing to a file in the \textit{Releases} section, but only for a specific release.
Therefor, if anyone wishes to programmatically fetch a file uploaded in the latest release, the GitHub API must be utilized.
It is then possible to iterate all the uploaded assets and read their names or URLs, among other properties.

\subsection{LimeTech}

LimeTech is not used by the public but rather a single developer, who also is a major contributor to both SourceMod and SourcePawn.
The website hosts files for many popular extensions, making it worthwhile to consider when finding the way to standardize distribution.

Like the forums and GitHub, it lacks a URL to download the latest publication of a project from.
And due to a lack of an API, one must resolve to scraping.
All the project releases hosted on the website are archives.
They are kept on pages of their own, in a three-column table of operating systems to specific versions.
A caveat here may be that a cell is empty, either because a certain release for a specific system is not out yet, or is simply not supported.
Thus a traversal of the table is required to find the next, latest one available.

\subsection{Other websites}

Because of the heuristic nature of the solution for standardizing distribution, support for all websites is impossible.
The top three mentioned ones are where all plugins are found, save for a few exceptions.
And all of them require a dedicated solution in order to fetch the files.

Having said that, the only information that is needed about a file is its name and download URL.
If both are provided as a single string of data, it can be utilized to implement a generic solution agnostic of the website.
This generic solution must not rely on any sort of API or a scraping method.
It may only download a file from a specific URL and save it under appropriate name and directory.
Limited of a solution as it is, it opens up possibility to support a whole range of websites.

A notable example here is BitBucket, an alternative to GitHub.
BitBucket has a \textit{Downloads} section, where each file is addressed by name.
Because of this, it is trivial to provide download URLs for the latest version of published files that need no specific processing.
Unlike attachments in case of the official forums, for example, which are required to be scraped.
Likewise, any website with a similar simplistic functionality is integrable with.

\section{AlliedModders' database}

When a developer creates a thread on AlliedModders to promote their plugin, they are asked to fill a short form about it.
This form contains fields such as the description, category, or applicable games.
Upon submittal, the thread is assigned a unique ID under which the plugin's metadata is saved in the forums' database.
They are then displayed along with this plugin ID in a header unique to threads in the \textit{Plugins} section of the forums.
Underneath, the author attaches applicable files, or points where to download them from.

For the vast majority of plugins, a thread is guaranteed to exist and the database is a promising source of metadata about plugins.
Unfortunately, it may not be used for four main reasons:
\begin{enumerate}
\item
No API to read from the database is available to third-parties.
Developing it would require support from the website maintainers, and although sought after, cannot be relied upon in early stages of the project.
\item
Post attachments are not tied to the plugin ID.
At best, they may be scraped after finding the associated thread.
Not to mention the fact, that the file download URLs need not be present in the post at all.
\item
There still is the problem of a non standardized way of installing the plugins.
By no means can the author's instructions be utilized for automating the process.
\item
Plugin ID may not exist for every installable addon for SourceMod.
Though ill-advised and rare, the author is not required to make a thread should they want to publish their work on other websites only.
Furthermore, SourceMod extensions have their own section, unrelated completely to that of plugins'.
There, no plugin ID or database entry is present.
And considering extensions have an analogous installation process and may be dependencies to other addons, they are worth supporting.
Lastly, in exceptionally rare situations, an extension may be simplified to become a plugin, and moved to the \textit{Plugins} section.
No database triggers will run, and it will be left as an atypical plugin lacking its ID.
\end{enumerate}

To combat the above issues, a custom database is set up.

\section{SourceMod Addon Manager database}

As per every package manager, there exists a corresponding repository of software packages.
For a solution to SourceMod community's distribution problem, such a repository may not host files.
What it can store is the data about files which constitute a package, and where they can be downloaded from.
The crucial part is defining the format of metadata to fit plugins which are distributed across the three aforementioned websites.

Anyone should be able to describe a plugin to the system, regardless whether it is self-developed or not.
One of the most important concepts of the project is not requiring any action from other developers.
As such, the maintainer is separated from the author.
After providing the plugin specification, the rest should be taken care of automatically.
For instance, if the author releases a new version, it should not require any update from the side of the maintainer.
The plugin data is parsed by the client application, which should be able to fetch the most recent version, adapting the method to the website it detected.

To properly define a package, the following metadata must be provided, for specific reasons:
\begin{enumerate}
    \item \textbf{Name} -- Unique, case-insensitive name of the plugin; for identification, installation and searching.
    \item \textbf{Author} -- Name the original author goes by, which may differ from the maintainer; for searching.
    \item \textbf{Description} -- Short description of the idea behind the plugin; for searching.
    \item \textbf{Category} -- Category name as it appears on the AlliedModders forums; for searching.
    \item \textbf{Plugin ID} -- Plugin ID number as it appears AlliedModders forums' plugin's thread; for possible future integration.
    \item \textbf{Base URL} -- URL associated with the plugin; for installation.
    \item \textbf{Files} -- Paths and filenames defining an plugin; for installation.
    \item \textbf{Games} -- Multiple choice field defining which games the plugin works for, may be all; for searching.
    \item \textbf{Dependencies} -- Names of other plugins which this plugin is dependent upon; for installation.
\end{enumerate}

\subsection{Fields utilized for searching}

Optional but equally as important aspects of the database are its search capabilities.
Akin to AlliedModders' database, there exist fields like description, category or games.
The category is a single choice list: \textit{Admin Commands}, \textit{Fun Stuff}, \textit{Gameplay}, \textit{General Purpose}, \textit{Server Management}, \textit{Statistical}, \textit{Technical/Development}.
Similarly to author, description, or games, it is used purely for searching purposes.
The applicable games could be enforced during the installation, but often so it happens that plugin works for more games than specified by the author.

\subsection{Plugin ID}

Plugin ID is as it appears on the forums.
It serves no purpose in the early stages of the project, but might be useful should the official integration come in.
Should it, there will be no need to store the author, description or category, as all three could be fetched from the forums' database.
This way, data would not be needlessly duplicated and be required to be entered twice by the person submitting.
This feature can only be supplied for plugins, as extensions or rare cases of plugins have no ID.

\subsection{Base URL}

Base URL is the first of the two most important fields of the project.
It is by this field the website will be detected by the client-side application, after which the appropriate method of parsing will be used.
Each plugin entry must have this field carefully selected based on the website by the submitter.

\subsubsection{AlliedModders}

In case of AlliedModders, this will be the URL to the post containing the files.
From there, the client is able to scrape the attachments.
It is also possible to provide a link to the entire thread, instead of only the original post, or any webpage from which post attachments can be accessed.

\subsubsection{GitHub}

As mentioned, in GitHub it is possible to provide a URL to the latest version of the file in a repository.
This is what is used in the generic solution used for unknown websites.
However, GitHub API usage is required to parse a specific file from the latest release.
Should this functionality be needed, a URL to the repository may be entered.
After that, it is trivial for the client to find the \textit{Releases} API page and fetch the files published there.

\subsubsection{LimeTech}

LimeTech in this sense is very simple.
Every project submitted there follows a standard of being an archive in a cell of a table.
All that is needed is scraping that table to find the latest version.
The project-specific page's URL is all the information the client needs to find the files.

\subsubsection{Other websites}

Base URL field for websites besides the main three is redundant.
This is because the field is used only to detect the parsing method, but none may be supported when the URL is unknown.
In such cases, the only thing left to fill is the \textit{Files} field appropriately.

\subsection{Files}

Files is the second of the two most important fields of the project.
This is the field the client uses to link attachments parsed from the \textit{Base URL} to the actual placement and names of the them on the disk.
Every file here is defined manually by the addon's maintainer in the following format: \verb|<path to file>;<file identifier>|.
The two fields must be separated by a semicolon.

\subsubsection{Path to file}

This is the property that relates directly to where the file belongs on the disk, it must be unique to server installation.
For convenience purposes, it is defined to be relative to SourceMod installation root.
From here there are the shortest paths to commonly used directories, for instance, \path{mod/addons/sourcemod/plugins}.

Relative paths are supported, such as "\verb|..|" to go up a directory.
This is required because, as previously mentioned, addon files may not be limited to the SourceMod directories.
A possible security flaw appears here, as the maintainer can exploit this freedom to move up as many directories as they please.
This must be accounted for and limited to the server installation, such as \path{mod/}.
An enforcement is present on the client side, making it impossible to go up more than two directories.
Furthermore, it is illegal to enter any non-directory locations, such as symlinks or mounted drives.

\subsubsection{File identifier}

This property relates to the attachment names retrieved from the \textit{Base URL}.
If this identifier is just a name of the file, it is cross-referenced with the attachments found.
Should it match one, the URL the attachment points to will be used to download and save the file under \path{{path/to/file}/{identifier}}.

The file identifier can also be a URL.
In this case the retrieved attachments are not used, since the URL is already known.
It is downloaded and saved in a similar manner, whatever legal location \textit{path to file} points to.
This is the reason the explicit semicolon separation is needed, to clearly distinguish what could be either a URL or a simple file name.

There is a third possibility, in case the name of the file is not static.
The actual name itself is not prone to change, however, the may be situations when a developer includes a version number.
This happens most often when a whole project is archived but may also come up when the plugin is a single binary file.
For this purpose, the support for regex-defined file identifiers is needed.
This will ensure the version number could be dynamic.
In such case, it is possible to match against multiple attachments.
Only one may be valid, however assuming their only difference is the version number, it is trivial to compare them to retrieve the latest one.

\subsection{Dependencies}

Dependencies on the forums are for the end user to note the prerequisites, they are listed as plugin IDs linking to appropriate threads.
The dependencies field in this project are not specifically for viewing, but are rather used in the installation.
In practise, it is quite rare for a plugin to have dependency on another.
But the less often it happens, the more surprising it may be when a plugin refuses to load.

This field is simply a string of addon names separated by comma.
Just as the names themselves, the dependencies are agnostic of whether they refer to a plugin or an extension.
For implementation-specific reasons, dependency addons must be installed prior.

\subsection{Deployment}

\subsubsection{Security}

The database is set up on a virtual private server provided by \textit{Digital Ocean}.
Interaction is achieved through an web server bound to a custom domain name -- \path{smamdb.net}.
Communication with that server is end-to-end encrypted with TLS using a certificate issued by \textit{Let's Encrypt}.
This warrants three important aspects of fetching packages:
\begin{enumerate}
\item \textbf{Authenticity} ensures that the web server the client interacts with is indeed owned by a trusted party.
\item \textbf{Integrity} takes care of fetching the data fully and correctly, without falling victim to potential tampering during transfer.
\item Despite being less important in this situation, \textbf{confidentiality} keeps the connection between the client and the web server private.
\end{enumerate}

Plugins have access to many sensitive parts of the server including database connections or the file system.
Because of this, it is important to ensure authenticity of the metadata retrieved.
This, of course, does not warrant full safety as the metadata itself could lead to vulnerable endpoints.
One reason could be that the developer who is publishing their work fancies distributing it on their own website, which happens to be unsecure.
Another reason could be that the attacker had gained access to publishing or editing plugins, rendering them compromised.

By using the OAuth2 protocol, Valve provides third-party authentication mechanism against their Steam services.
It is by these mechanisms that publishers are recognised and validated, as each of them is expected to have a Steam account.
Not everyone is allowed to publish their work on the website by default.
The user must be trusted in order to have access, and that trust is granted by a moderator.
Moderators, in turn, are created by the owner.
Furthermore, each submission is tied to the submitter, they may edit or delete their submissions but not others'.
Once again, somebody may publish the plugin for the developer instead, so they are not required to have access to make use of the service.

\subsubsection{Interaction API}

To interact with the database the client sends GET requests to \url{https://smamdb.net/}.
For installation purposes, only the \verb|ids| parameter must be supplied, which is a single name or multiple names of addons separated by a comma.
As a response, the server provides a list of JSON objects representing data about each addon requested, with the following fields:
\begin{itemize}
    \item \textbf{id} -- name of the addon,
    \item \textbf{author} -- to be saved locally for displaying,
    \item \textbf{description} -- to be saved locally for displaying,
    \item \textbf{url} -- \textit{Base URL} which to parse,
    \item \textbf{files} -- definition of files to be searched on said URL,
    \item \textbf{deps} -- list of dependencies, skipped if there are none.
\end{itemize}

If there is more than one dependency, the server is forced to recursively retrieve all of them.
This makes it possible to return a longer list of addon objects than requested.
Furthermore, an action is taken to ensure each addon is provided only once in the list, and not processed for dependencies again.

\subsubsection{Management Interface}

\subsubsection{Self distribution}

\url{https://smamdb.net/interface/}

\section{SourceMod Addon Manager}

\section{Unsupported features}

TODO: explain the impossibility of the following

\subsection{Installing specific version}
